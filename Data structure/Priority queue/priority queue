/**
 * This function swaps void pointer 1 with void pointer 2.
 */
void swap(struct array *a, long int index_1, long int index_2)
{
    void *p = array_get(a, index_1);
    array_set(a, index_1, array_get(a, index_2));
    array_set(a, index_2, p);
}

/**
 * This function compares the last added pointer with his parent, if the last
 * added pointer is less than his parent, swap the pointer with his parent.
 * Repeat until there is no parent anymore or the parent is less than the last
 * added pointer.
 * @param a array
 * @param compare compare function(for more information see main.c)
 */
void percolate_up(struct array *a, int (*compare)(const void *, const void *))
{
    //! index of last added pointer
    long int size_array = array_size(a) - 1;
    long int index = size_array;
    //! index of his parent
    long int parent = (index - 1) / 2;
    while (1)
    {
        //! if the added pointer is the root of the heap.
        if (index == 0)
        {
            break;
        }
        //! compare the value with his parent
        int compare_value = compare(array_get(a, index), array_get(a, parent));
        //! if the value is less than 0 then swap
        if (compare_value < 0)
        {
            swap(a, index, parent);
            index = parent;
            parent = (index - 1) / 2;
        }
        //! else, it means the pointer is on the right position
        else
        {
            break;
        }
    }
}

/**
 * This function compares the root pointer with his child, if the child is less
 * than the root pointer, swap the child with the root pointer. Repeat until
 * the pointer is on the right position.
 * @param a array
 * @param compare compare function(for more information see main.c)
 */
void percolate_down(struct array *a, int (*compare)(const void *, const void *))
{
    //! index of last pointer in the array
    long int size_array = array_size(a) - 1;
    //! index of root
    long int index = 0;
    long int left_child = index * 2 + 1;
    long int right_child = index * 2 + 2;
    while (1)
    {
        //! if there is no child then break the while loop
        if (left_child > size_array)
        {
            break;
        }
        //! compare the pointer with his left child
        int value_left = compare(array_get(a, left_child), array_get(a, index));
        //! if the there is no right child and left child is less than pointer
        //! then swap left child with pointer
        if (right_child > size_array && value_left < 0)
        {

            swap(a, index, left_child);
            break;
        }
        //! if right child and left child is biggen than the pointer then break
        else if (right_child > size_array && value_left >= 0)
        {
            break;
        }
        //! compare the pointer with his left child
        int value_right = compare(array_get(a, right_child), array_get(a, index));
        //! if the right child or/and left child is less than the pointer
        if (value_left < 0 || value_right < 0)
        {
            //! if both child is less than the pointer
            if (value_left == value_right)
            {
                //! compare left with right child
                int value = compare(array_get(a, left_child),
                                    array_get(a, right_child));
                //! if left child is less than right child then swap with left
                //! child
                if (value < 0)
                {
                    swap(a, left_child, index);
                    index = left_child;
                    left_child = index * 2 + 1;
                    right_child = index * 2 + 2;
                }
                //! else swap with right child
                else
                {
                    swap(a, right_child, index);
                    index = right_child;
                    left_child = index * 2 + 1;
                    right_child = index * 2 + 2;
                }
            }
            //! if left child is less than the pointer but right child is
            //! greater than the pointer, swap with left child
            else if (value_left < value_right)
            {
                swap(a, index, left_child);
                index = left_child;
                left_child = index * 2 + 1;
                right_child = index * 2 + 2;
            }
            //! else swap with right child
            else
            {
                swap(a, index, right_child);
                index = right_child;
                left_child = index * 2 + 1;
                right_child = index * 2 + 2;
            }
        }
        else
        {
            break;
        }
    }
}
/**
 * This function creates a priority queue and returns a pointer to it.
 *
 * @param compare compare function, for more information see main.c
 * @return a pointer to the prioq that is allocated on the heap
 */
static struct heap *heap_init(int (*compare)(const void *, const void *))
{
    //! allocate struct heap on the heap
    struct heap *new_heap = malloc(sizeof(struct heap));
    //! return NULL if failed
    if (new_heap == NULL)
    {
        return NULL;
    }
    //! allocate a 2D array on the heap with size 10
    new_heap->array = array_init(10);
    //! return NULL if failed and free the struct heap
    if (new_heap->array == NULL)
    {
        free(new_heap);
        return NULL;
    }
    new_heap->compare = compare;
    //! return the new heap
    return new_heap;
}

/**
 * This function creates a priority queue and returns a pointer to it.
 *
 * @param compare compare function, for more information see main.c
 * @return a pointer to the prioq that is allocated on the heap
 */
prioq *prioq_init(int (*compare)(const void *, const void *))
{
    return heap_init(compare);
}

/**
 * This function return the size of priority queue.
 *
 * @param q the priority queue
 * @return the size of queue
 */
long int prioq_size(prioq *q)
{
    return array_size(q->array);
}

/**
 * This function cleans up the priority queue
 *
 * @param free_func the free function
 * @param h input prioq
 * @return 0 if successfull else return -1
 */
static int heap_cleanup(struct heap *h, void free_func(void *))
{
    //! if prioq is NULL or array is NULL
    if (h == NULL || h->array == NULL)
    {
        return -1;
    }
    //! free priority queue
    array_cleanup(h->array, free_func);
    //! free struct heap
    free(h);
    return 0;
}

/**
 * This function cleans up the priority queue
 *
 * @param free_func the free function
 * @param q input queue
 * @return 0 if successfull else return -1
 */
int prioq_cleanup(prioq *q, void free_func(void *))
{
    return heap_cleanup(q, free_func);
}

/**
 * This function inserts a void pointer to the priority queue
 *
 * @param h priority queue
 * @param p void pointer
 * @return 0 if successfull else return -1
 */
static int heap_insert(struct heap *h, void *p)
{
    //! if prioq is NULL or p is NULL or array is NULL
    if (h == NULL || p == NULL || h->array == NULL)
    {
        return -1;
    }
    //! if append p failed return -1
    if (array_append(h->array, p) == -1)
    {
        return -1;
    }
    //! percolate up the last added pointer if possible
    percolate_up(h->array, h->compare);
    return 0;
}

/**
 * This function inserts a void pointer to the priority queue
 *
 * @param q priority queue
 * @param p void pointer
 * @return 0 if successfull else return -1
 */
int prioq_insert(prioq *q, void *p)
{
    return heap_insert(q, p);
}

/**
 * This function pops the top element from the prioq and return it
 *
 * @param h priority queue
 * @return the top element if successfull else return NULL
 */
static void *heap_pop(struct heap *h)
{
    //! if prioq is NULL or p is NULL or array is NULL
    if (h == NULL || h->array == NULL || array_size(h->array) == 0)
    {
        return NULL;
    }
    //! index of last pointer in the array
    long int index_last = array_size(h->array) - 1;
    //! swap the top element with the last element
    swap(h->array, index_last, 0);
    //! pop the last element after swap
    void *pop = array_pop(h->array);
    //! percolate down the top element if possible
    percolate_down(h->array, h->compare);
    return pop;
}

/**
 * This function pops the top element from the prioq and return it
 *
 * @param q priority queue
 * @return the top element if successfull else return NULL
 */
void *prioq_pop(prioq *q)
{
    return heap_pop(q);
}
